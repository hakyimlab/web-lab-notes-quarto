{
  "hash": "dd9989da49e3a311f8528cf766754a3a",
  "result": {
    "markdown": "---\ntitle: Power calculator for  mol QTLs\nauthor: Haky Im\ndate: '2023-02-21'\nslug: power-calculator-for-mol-qtls\ncategories:\n  - how to\ntags: []\neditor_options: \n  chunk_output_type: console\n---\n\n\n## PORS power calculation\n\nThe success of the prediction training depends mostly on whether the corresponding QTL study will be powered. Thus, we provide here the power to detect molecular QTLs for a range of sample sizes, effect sizes, and minor allele frequencies.\n\n## function: R2 from beta assuming variance of y = 1\n\n$$y = \\delta \\cdot x + \\epsilon$$\n\n$$r^2 = \\delta^2 \\cdot \\text{var}(x) = \\delta^2 \\cdot 2 \\cdot \\text{maf} \\cdot (1-\\text{maf})$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressMessages(library(tidyverse))\nsuppressMessages(library(knitr))\n## install.packages(\"pwr\")\nif (!(\"pwr\" %in% installed.packages()[, 1])) {\n  install.packages(\"pwr\")\n}\n```\n:::\n\n\n## define ranges of maf, eff, sample sizes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmafvec = c(0.05, 0.10, 0.30) \neffvec = c(0.40, 0.60, 0.80) \nnvec = c(200,350,500) \nnsnps = 1000\nalpha = 0.05/nsnps\n```\n:::\n\n\n## create data frame with all combinations\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# mat = matrix(NA,length(mafvec)*length(effvec)*length(nvec),4)\n# colnames(mat) = c(\"maf\",\"eff\",\"nsam\",\"power\")\n# cont = 1\n# for(maf in mafvec)\n# {\n#   for(nn in nvec)\n#   {\n#     for(eff in effvec)\n#     {\n#       r2 = eff^2 * 2 * maf * (1-maf)\n#       rr = sqrt(r2)\n#       pp = pwr::pwr.r.test(n = nn, r= rr , sig.level = alpha)\n#       mat[cont,] = c(maf, eff, nn, pp$power)\n#       cont = cont + 1\n#     }\n#   }\n# }\n# \n# mat %>% data.frame() %>% \n#   pivot_wider(names_from = nsam, values_from = power) %>% \n#   mutate(across(3:ncol(.), ~sprintf(\"%.1f%%\", . * 100))) %>% \n#   kable(format = \"markdown\", align = c(\"l\", \"l\", \"c\", \"c\", \"c\"), \n#         caption = \"Power by sample size\") \n```\n:::\n\n\n## calculate detectable effect sizes\n\nThe following table shows the detectable effect sizes at 80% power with a significance level of 0.05/1000. Variance of Y is standardized to 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalc_mateff = function(mafvec,nvec,outmat=FALSE)\n{\n  mateff = matrix(NA,length(mafvec)*length(nvec),3)\ncolnames(mateff) = c(\"maf\",\"nsam\",\"power\")\ncont = 1\nfor(maf in mafvec)\n{\n  for(nn in nvec)\n  {\n      # r2 = eff^2 * 2 * maf * (1-maf)\n      # rr = sqrt(r2)\n      pp = pwr::pwr.r.test(n = nn, power=0.80 , sig.level = alpha)\n      eff = pp$r/sqrt(2*maf*(1-maf))\n      mateff[cont,] = c(maf,  nn, eff)\n      cont = cont + 1\n  }\n}\n  mateff = mateff %>% data.frame() %>% \n  pivot_wider(names_from = nsam, values_from = power) %>% \n  mutate_at(vars(-c(1)), ~round(., 2)) \n  print(mateff)\n  if(outmat) mateff\n} \n\nmafvec = c(0.05, 0.10, 0.30) \nnvec = c(100,500,1000,7000) \nnsnps = 1000\nalpha = 0.05/nsnps\n## ---\nmat = calc_mateff(mafvec,nvec,outmat=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 5\n    maf `100` `500` `1000` `7000`\n  <dbl> <dbl> <dbl>  <dbl>  <dbl>\n1  0.05  1.5   0.7    0.5    0.19\n2  0.1   1.09  0.51   0.36   0.14\n3  0.3   0.71  0.33   0.24   0.09\n```\n:::\n\n```{.r .cell-code}\nmat %>%  kable(format = \"markdown\", align = c(\"l\", \"c\", \"c\", \"c\", \"c\"), caption = \"Detectable effects w/1000 SNPs\",label=NA) \n```\n\n::: {.cell-output-display}\nTable: Detectable effects w/1000 SNPs\n\n|maf  | 100  | 500  | 1000 | 7000 |\n|:----|:----:|:----:|:----:|:----:|\n|0.05 | 1.50 | 0.70 | 0.50 | 0.19 |\n|0.10 | 1.09 | 0.51 | 0.36 | 0.14 |\n|0.30 | 0.71 | 0.33 | 0.24 | 0.09 |\n:::\n\n```{.r .cell-code}\nmafvec = c(0.05, 0.10, 0.30) \nnvec = c(1000,6000,10000,100000) \nnsnps = 1e6\nalpha = 0.05/nsnps\n## ---\nmat = calc_mateff(mafvec,nvec,outmat=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 5\n    maf `1000` `6000` `10000` `1e+05`\n  <dbl>  <dbl>  <dbl>   <dbl>   <dbl>\n1  0.05   0.64   0.26    0.2     0.06\n2  0.1    0.46   0.19    0.15    0.05\n3  0.3    0.3    0.13    0.1     0.03\n```\n:::\n\n```{.r .cell-code}\nmat %>%  kable(format = \"markdown\", align = c(\"l\", \"c\", \"c\", \"c\", \"c\"), caption = \"Detectable effects w/1e6 SNPs\",label=NA) \n```\n\n::: {.cell-output-display}\nTable: Detectable effects w/1e6 SNPs\n\n|maf  | 1000 | 6000 | 10000 | 1e+05 |\n|:----|:----:|:----:|:-----:|:-----:|\n|0.05 | 0.64 | 0.26 | 0.20  | 0.06  |\n|0.10 | 0.46 | 0.19 | 0.15  | 0.05  |\n|0.30 | 0.30 | 0.13 | 0.10  | 0.03  |\n:::\n:::\n\n\n## power for Xcan association (continuous X)\n\n::: {.cell}\n\n```{.r .cell-code}\nnvec = c(10000,100000,500000) \nntests = 10000\nalpha = 0.05/ntests\n\ncalc_matr = function(nvec,outmat=FALSE)\n{\n  mateff = matrix(NA,length(nvec),2)\n  colnames(mateff) = c(\"nsam\",\"r\")\n  cont = 1\n  for(nn in nvec)\n  {\n    pp = pwr::pwr.r.test(n = nn, power=0.80 , sig.level = alpha)\n    mateff[cont,] = c(nn, pp$r)\n    cont = cont + 1\n  }\n  mateff = mateff %>% data.frame() %>%  mutate(r2 = r^2) %>% mutate_at(vars(-c(1)), ~signif(., 2)) \n  print(mateff)\n  if(outmat) mateff\n} \n\ncalc_matr(nvec,outmat=TRUE) %>% knitr::kable()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   nsam      r      r2\n1 1e+04 0.0540 2.9e-03\n2 1e+05 0.0170 2.9e-04\n3 5e+05 0.0077 5.9e-05\n```\n:::\n\n::: {.cell-output-display}\n|  nsam|      r|      r2|\n|-----:|------:|-------:|\n| 1e+04| 0.0540| 2.9e-03|\n| 1e+05| 0.0170| 2.9e-04|\n| 5e+05| 0.0077| 5.9e-05|\n:::\n:::\n\n\nWith sample sizes of {`r nvec}, we can detect genes that affect \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}