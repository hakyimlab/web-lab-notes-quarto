{
  "hash": "94d0dddaa4db9d05eb4fc2874b263571",
  "result": {
    "markdown": "---\ntitle: Transcriptome QGT Training 2023\nauthor: Haky Im\ndate: '2022-06-10'\ndate-modified: last-modified\nformat:\n  html:\n    code-fold: false\n    code-summary: \"Show the code\"\n    code-tools: true\n    code-overflow: wrap\n---\n\n\n# Goals of Lab\n\n-   Predict whole blood expression from genotype\n-   Check how well the prediction works with GEUVADIS expression data\n-   Run association between predicted expression and a phenotype\n-   Calculate association between expression levels and coronary artery disease risk using s-predixcan\n-   Fine-map the coronary artery disease gwas results using torus\n-   Calculate colocalization probability using fastenloc\n-   Run cTWAS (fine-map SNPs and genes jointly)\n\n# Inital Remarks\n\n-   We ask you to actively participate in today's hands on activities.\n\n::: callout-note\nNotice that we may ask you to share your screen for pedagogic purposes.\n:::\n\n-   Send Haky a private message if you really don't want to be called to share your screen.\n\n-   If you have any concerns about this, please ask me or one of the TAs for assistance. We are here to help you learn.\n\n-   Open the questionnaire forms at the beginning of each section and answer the questions as you go along\n\n    -   Name is a mandatory field. You can use your name or a pseudonymn. Just keep using the same name for each submission\n    -   We will ask you to submit partial set of answers so that we can get a sense of where people are\n\n-   Through out the lab you will see code chucks that are written with bash, eval=FALSE in place of R. These chunks are meant to be run in your Rstudio terminal and not in the Rmarkdown file itself.\n\n-   R code chunks also have \"eval=FALSE\". When you click on the green triangle, the code will run in the R console but not when we knit the document. This just happened to be more convenient for us to generate a knitted html.\n\n# Set Up\n\n## Questionnaire 01\n\n-   [ ] Open and start filling questionnaire 01 Preliminary questionnaire https://forms.gle/fhNJAyjx7MJTy3yt8\n\n-   [ ] Install packages as needed\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# List of packages you want to install\npackages <- c(\"tidyverse\", \"data.table\", \"BEDMatrix\", \"Rfast\", \"susieR\", \"coloc\")\n\n# Function to check and install any missing packages\ncheck_and_install <- function(pkg){\n  if (!require(pkg, character.only = TRUE)) {\n    install.packages(pkg, dependencies = TRUE)\n    library(pkg, character.only = TRUE)\n  }\n}\n\n# Use the function to check and install packages\nsapply(packages, check_and_install)\n```\n:::\n\n\n-   [ ] Load Rstudio Libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n## packages needed for susie+coloc\nlibrary(data.table)\nlibrary(BEDMatrix)\nlibrary(Rfast)\nlibrary(susieR)\nlibrary(coloc)\n##library(tidyverse)\n```\n:::\n\n\n-   [ ] Navigate to starting directory\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd \"/cloud/project/\"\n```\n:::\n\n\n-   [ ] activate the the imlabtools environment, which will make sure that the right version of python modules are available\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nconda activate imlabtools\n```\n:::\n\n\n-   [ ] To define some variables to access the data more easily within the R session, run the following r chunk\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(getwd())\n\nlab=\"/cloud/project/QGT-Columbia-HKI-repo/\"\nCODE=glue::glue(\"{lab}/code\")\nsource(glue::glue(\"{CODE}/load_data_functions.R\"))\nsource(glue::glue(\"{CODE}/plotting_utils_functions.R\"))\n\nPRE=\"/cloud/project/QGT-Columbia-HKI-repo/box_files\"\nMODEL=glue::glue(\"{PRE}/models\")\nDATA=glue::glue(\"{PRE}/data\")\nRESULTS=glue::glue(\"{PRE}/results\")\nMETAXCAN=glue::glue(\"{PRE}/repos/MetaXcan-master/software\")\nFASTENLOC=glue::glue(\"{PRE}/repos/fastenloc-master\")\n\n# This is a reference table we'll use a lot throughout the lab. It contains information about the genes.\ngencode_df = load_gencode_df()\n```\n:::\n\n\n-   [ ] check the values of the variables you just defined in R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMODEL\n\nDATA\n```\n:::\n\n\n-   [ ] define some variables to access the data more easily in the terminal. Remember we are running R code in the R console and command line code in the terminal.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nexport PRE=\"/cloud/project/QGT-Columbia-HKI-repo/box_files\"\nexport LAB=\"/cloud/project/QGT-Columbia-HKI-repo/\"\nexport CODE=$LAB/code\nexport DATA=$PRE/data\nexport MODEL=$PRE/models\nexport RESULTS=$PRE/results\nexport METAXCAN=$PRE/repos/MetaXcan-master/software\n```\n:::\n\n\n-   [ ] check the values of the variables you just defined\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n\necho $CODE\necho $RESULTS\n\n```\n:::\n\n\n# Transcriptome-wide association (Review)\n\nNow we will perform a transcriptome-wide association analysis using the PrediXcan suite of tools. ![Transcriptome-wide association methods](https://raw.githubusercontent.com/hakyimlab/QGT-Columbia-HKI/master/extras/figures/Association-Methods.png)\n\nWe start by predicting the expression levels of genes using the genotype data and the prediction weights and then perform an association between the predicted expression and the phenotype (denoted trait in the figure below).\n\n![](https://raw.githubusercontent.com/hakyimlab/QGT-Columbia-HKI/master/extras/figures/PrediXcan-run.png)\n\n## Questionnaire 02\n\n-   [ ] Open and start filling questionnaire 02 Prediction https://forms.gle/T6kAHvFTxYfcQguW7\n\n# Predict Expression from genotype\n\nIn this section we will predict expression of genes in whole blood using the Predict.py code in the METAXCAN folder.\n\n-   Prediction models (weights) are located in the MODEL folder. Additional models for different tissues and transcriptome studies can be downloaded from [predictdb.org](http://predictdb.org).\n\n-   This run should take about one minute.\n\n-   [ ] run the following code in the terminal.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nprintf \"Predict expression\\n\\n\"\npython3 $METAXCAN/Predict.py \\\n--model_db_path $PRE/models/gtex_v8_en/en_Whole_Blood.db \\\n--vcf_genotypes $DATA/predixcan/genotype/filtered.vcf.gz \\\n--vcf_mode genotyped \\\n--variant_mapping $DATA/predixcan/gtex_v8_eur_filtered_maf0.01_monoallelic_variants.txt.gz id rsid \\\n--on_the_fly_mapping METADATA \"chr{}_{}_{}_{}_b38\" \\\n--prediction_output $RESULTS/predixcan/Whole_Blood__predict.txt \\\n--prediction_summary_output $RESULTS/predixcan/Whole_Blood__summary.txt \\\n--verbosity 9 \\\n--throw\n```\n:::\n\n\n> Note we are only predicting chromosome 22 here (check by running \"predicted_expression %\\>% count(chromosome)\" in the console)\n\n-   [ ] run following code in the console to get information on reported prediction performance.\n\n> Find additional information [in this wiki](https://github.com/hakyimlab/MetaXcan/wiki/Individual-level-PrediXcan:-introduction,-tutorials-and-manual)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprediction_fp = glue::glue(\"{RESULTS}/predixcan/Whole_Blood__predict.txt\")\n\n## Read the Predict.py output into a dataframe. This function reorganizes the data and adds gene names.\npredicted_expression = load_predicted_expression(prediction_fp, gencode_df)\n\nhead(predicted_expression)\n\n## read summary of prediction, number of SNPs per gene, cross validated prediction performance\nprediction_summary = load_prediction_summary(glue::glue(\"{RESULTS}/predixcan/Whole_Blood__summary.txt\"), gencode_df)\n## number of genes with a prediction model\ndim(prediction_summary)\nhead(prediction_summary)\n\n## how many unique genes were predicted?\npredicted_expression %>% .[[\"gene_id\"]] %>% unique() %>% length()\n\n## gene expression were predicted for how many people?\npredicted_expression %>% .[[\"IID\"]] %>% unique() %>% length()\n\nprint(\"distribution of prediction performance r2\")\nsummary(prediction_summary$pred_perf_r2)\nhist(prediction_summary$pred_perf_r2)\n## Note: this is what the prediction trainer reported as prediction performance\n```\n:::\n\n\n## (Optional) Assess Actual Prediction Performance\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## download and read observed expression data from GEUVADIS \n## from https://uchicago.box.com/s/4y7xle5l0pnq9d1fwmthe2ewhogrnlrv\n\nobs_exp<- read_csv(glue::glue(\"{DATA}/predixcan/GEUVADIS.observed_df.csv.gz\"))\n\n## Note that the version of the ensemble id of the gene was removed\nhead(predicted_expression)\n\n## Q: how many genes were predicted?\nlength(unique(predicted_expression$gene_id))\n\n## inner join predicted expression with observed expression data (by IID and gene)\n## common errors occur when ensemble id's have versions in one set and not the other set\nfullset=inner_join(predicted_expression, obs_exp, by = c(\"gene_id\",\"IID\"))\n\n## calculate spearman correlation for all genes\ngenelist = unique(predicted_expression$gene_id)\ncorvec = rep(NA,length(genelist))\nnames(corvec) = genelist\nfor(gg in 1:length(genelist))\n{\n  ind = fullset$gene_id==genelist[gg]\n  corvec[gg] = cor(fullset$predicted_expression[ind], fullset$observed_expression[ind])\n}\n\n## what's the best performing gene?\n\n## plot the histogram of the prediction performance\nhist(corvec)\n\n## list the top 10 best performing genes\nhead(sort(corvec,decreasing = TRUE),2)\ntail(sort(corvec,decreasing = TRUE),2)\n\n## plot the correlation of the top 2 best performing genes bottom 2\n\ngeneid = \"ENSG00000100376\"\ngenename = gencode_df %>% filter(gene_id==geneid) %>% .[[\"gene_name\"]]\nfullset %>% filter(gene_id==geneid) %>% ggplot(aes(observed_expression, predicted_expression))+geom_point()+ggtitle(paste(genename, \"-\",geneid))\n\ngeneid = \"ENSG00000075234\"\ngenename = gencode_df %>% filter(gene_id==geneid) %>% .[[\"gene_name\"]]\nfullset %>% filter(gene_id==geneid) %>% ggplot(aes(observed_expression, predicted_expression))+geom_point()+ggtitle(paste(genename, \"-\", geneid))\n\ngeneid = \"ENSG00000070371\"\ngenename = gencode_df %>% filter(gene_id==geneid) %>% .[[\"gene_name\"]]\nfullset %>% filter(gene_id==geneid) %>% ggplot(aes(observed_expression, predicted_expression))+geom_point()+ggtitle(paste(genename, \"-\", geneid))\n\ngeneid = \"ENSG00000184164\"\ngenename = gencode_df %>% filter(gene_id==geneid) %>% .[[\"gene_name\"]]\nfullset %>% filter(gene_id==geneid) %>% ggplot(aes(observed_expression, predicted_expression))+geom_point()+ggtitle(paste(genename, \"-\", geneid))\n```\n:::\n\n\n# Run PrediXcan association\n\n## Questionnaire 03\n\n-   [ ] Open and start filling questionnaire 03 PrediXcan https://forms.gle/3H319knWbLgnynNs9\n\nWe are going to use a simulated phenotype for which only UPK3A has an effect on the phenotype ($\\beta=-0.9887378$)\n\n$Y = \\sum_k T_k \\beta_k + \\epsilon$\n\nwith random effects $\\beta_k \\sim (1-\\pi)\\cdot \\delta_0 + \\pi\\cdot N(0,1)$\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n\nexport PHENO=\"sim.spike_n_slab_0.01_pve0.1\"\n\nprintf \"association\\n\\n\"\npython3 $METAXCAN/PrediXcanAssociation.py \\\n--expression_file $RESULTS/predixcan/Whole_Blood__predict.txt \\\n--input_phenos_file $DATA/predixcan/phenotype/$PHENO.txt \\\n--input_phenos_column pheno \\\n--output $RESULTS/predixcan/$PHENO/Whole_Blood__association.txt \\\n--verbosity 9 \\\n--throw\n\n```\n:::\n\n\nMore predicted phenotypes can be found in \\$DATA/predixcan/phenotype/. The naming of the phenotypes provides information about the genetic architecture: the number after pve is the proportion of variance of Y explained by the genetic component of expression. The number after spike_n\\_slab represents the probability that a gene is causal π (i.e. prob β≠0)\n\n## Looking at Association Results\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## read association results\nPHENO=\"sim.spike_n_slab_0.01_pve0.1\"\n\npredixcan_association = load_predixcan_association(glue::glue(\"{RESULTS}/predixcan/{PHENO}/Whole_Blood__association.txt\"), gencode_df)\n\n## take a look at the results\ndim(predixcan_association)\npredixcan_association %>% arrange(pvalue) %>% select(gene_name,effect,se,pvalue,gene) %>% head\npredixcan_association %>% arrange(pvalue) %>% ggplot(aes(pvalue)) + geom_histogram(bins=10)\n## compare distribution against the null (uniform)\ngg_qqplot(predixcan_association$pvalue, max_yval = 40)\n```\n:::\n\n\n## Comparing the Estimated Effect Size with True Effect Size\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntruebetas = load_truebetas(glue::glue(\"{DATA}/predixcan/phenotype/gene-effects/{PHENO}.txt\"), gencode_df)\nbetas = (predixcan_association %>% \n               inner_join(truebetas,by=c(\"gene\"=\"gene_id\")) %>%\n               select(c('estimated_beta'='effect', \n                        'true_beta'='effect_size',\n                        'pvalue', \n                        'gene_id'='gene', \n                        'gene_name'='gene_name.x', \n                        'region_id'='region_id.x')))\nbetas %>% arrange(pvalue) %>% select(gene_name,estimated_beta,true_beta,pvalue) %>% head\n## do you see examples of potential LD contamination?\nbetas %>% mutate(causal= true_beta!=0) %>% ggplot(aes(estimated_beta, true_beta,col=causal))+geom_point(alpha=0.6,size=5)+geom_abline()+theme_bw()\n```\n:::\n\n\n> UPK3A is the causal gene and has the most significant pvalue. RIBC2 is also significantly associated but has no causal role (we know because we simulated the phenotype that way). Why?\n\nHint: correlation between the genes\n\n# Run Summary PrediXcan\n\nNow we will use the summary results from a GWAS of coronary artery disease to calculate the association between the genetic component of the expression of genes and coronary artery disease risk. We will use the SPrediXcan.py.\n\n![](https://uchicago.box.com/shared/static/m45nnkeskzh88ifnv8td5e3fntdfzhjs.png)\n\nThe GWAS results (harmonized and imputed) for coronary artery disease are available in \\$PRE/spredixcan/data/\n\n## Questionnaire 04\n\n-   [ ] Open and start filling questionnaire 04 S-PrediXcan https://forms.gle/xJs2U66cnrqdb5cj6\n\n## Running S-PrediXcan\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n\npython $METAXCAN/SPrediXcan.py \\\n--gwas_file  $DATA/spredixcan/imputed_CARDIoGRAM_C4D_CAD_ADDITIVE.txt.gz \\\n--snp_column panel_variant_id \\\n--effect_allele_column effect_allele \\\n--non_effect_allele_column non_effect_allele \\\n--zscore_column zscore \\\n--model_db_path $MODEL/gtex_v8_mashr/mashr_Whole_Blood.db \\\n--covariance $MODEL/gtex_v8_mashr/mashr_Whole_Blood.txt.gz \\\n--keep_non_rsid \\\n--additional_output \\\n--model_db_snp_key varID \\\n--throw \\\n--output_file $RESULTS/spredixcan/eqtl/CARDIoGRAM_C4D_CAD_ADDITIVE__PM__Whole_Blood.csv\n\n```\n:::\n\n\n> We can run the full genome because the summary statistics based PrediXcan is much faster than individual level one.\n\n## Plot and Interpret Results\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspredixcan_association = load_spredixcan_association(glue::glue(\"{RESULTS}/spredixcan/eqtl/CARDIoGRAM_C4D_CAD_ADDITIVE__PM__Whole_Blood.csv\"), gencode_df)\ndim(spredixcan_association)\nspredixcan_association %>% arrange(pvalue) %>% head\nspredixcan_association %>% arrange(pvalue) %>% ggplot(aes(pvalue)) + geom_histogram(bins=20)\n\ngg_qqplot(spredixcan_association$pvalue)\n```\n:::\n\n\n-   *Question:* SORT1, considered to be a causal gene for LDL cholesterol and as a consequence of coronary artery disease, is not found here. Why?\n\n-   [ ] check whether SORT1 is expressed in whole blood [GTEx portal](https://gtexportal.org/home/gene/SORT1)\n\n-   [ ] check whether SORT1 has eQTL in whole blood [GTEx portal](https://gtexportal.org/home/gene/SORT1)\n\n## Run S-PrediXcan using gene expression predicted in liver\n\n-\\[\\] Run s-predixcan with liver model, do you find SORT1? Is it significant?\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n#loction Liver models \n#/cloud/project/QGT-Columbia-HKI-repo/box_files/models/gtex_v8_mashr/\npython $METAXCAN/SPrediXcan.py \\\n--gwas_file  $DATA/spredixcan/imputed_CARDIoGRAM_C4D_CAD_ADDITIVE.txt.gz \\\n--snp_column panel_variant_id \\\n--effect_allele_column effect_allele \\\n--non_effect_allele_column non_effect_allele \\\n--zscore_column zscore \\\n--model_db_path $MODEL/gtex_v8_mashr/mashr_Liver.db \\\n--covariance $MODEL/gtex_v8_mashr/mashr_Liver.txt.gz \\\n--keep_non_rsid \\\n--additional_output \\\n--model_db_snp_key varID \\\n--throw \\\n--output_file $RESULTS/spredixcan/eqtl/CARDIoGRAM_C4D_CAD_ADDITIVE__PM__Liver.csv\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nspredixcan_association_L= load_spredixcan_association(glue::glue(\"{RESULTS}/spredixcan/eqtl/CARDIoGRAM_C4D_CAD_ADDITIVE__PM__Liver.csv\"), gencode_df)\ndim(spredixcan_association_L)\nspredixcan_association_L %>% arrange(pvalue) %>% head\nspredixcan_association_L %>% arrange(pvalue) %>% ggplot(aes(pvalue)) + geom_histogram(bins=20)\n\ngg_qqplot(spredixcan_association_L$pvalue)\ncol_order= c(\"gene_name\",\"gene\",\"zscore\",\"effect_size\",\"pvalue\",\"var_g\",\"pred_perf_r2\", \"pred_perf_pval\",\"pred_perf_qval\", \"n_snps_used\", \"n_snps_in_cov\", \"n_snps_in_model\",\"best_gwas_p\",\"largest_weight\")\nspredixcan_association_L <- spredixcan_association_L[, col_order]\nfilter(spredixcan_association_L, gene_name==\"SORT1\")\n```\n:::\n\n\n## (Optional) Compare zscores in liver and whole blood.\n\n> Recall that zscore is the effect size divided by the standard error\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspredixcan_association_L=rename(spredixcan_association_L, zscore_liver = \"zscore\")\nhead(spredixcan_association_L)\ntest=left_join(spredixcan_association, spredixcan_association_L, by=\"gene_name\")\ntest=select(test,\"gene_name\",\"zscore\",\"zscore_liver\")\ntest %>% arrange(zscore_liver) %>% head\n\ntest %>% mutate(zscore_WB=zscore) %>% ggplot(aes(zscore_WB,zscore_liver)) + geom_point(size=3,alpha=.6) + geom_abline()\n\n## S-PrediXcan association in liver and whole blood are significantly correlated\ncor.test(test$zscore,test$zscore_liver)\n```\n:::\n\n\n## (Optional) Run MultiXcan\n\n-   multixcan aggregates information across multiple tissues to boost the power to detect association. It was developed movivated by the fact that eQTLs are shared across multiple tissues, i.e. many genetic variants that regulate expression are common across tissues.\n\n-   before you run multixcan ensure you have run s-predixcan for all the tissues you want to multixcan. In this tutorial we have two tissues (liver and whole blood), ensure you have run s-predixcan with the two tissues before running multixcan.\n\n-   One thing to note is to ensure similar naming pattern for the output files. This is to ensure the files are captured correctly when running multixcan's filter.\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n\npython $METAXCAN/SMulTiXcan.py \\\n--models_folder $MODEL/gtex_v8_mashr \\\n--models_name_pattern \"mashr_(.*).db\" \\\n--snp_covariance $MODEL/gtex_v8_expression_mashr_snp_smultixcan_covariance.txt.gz \\\n--metaxcan_folder $RESULTS/spredixcan/eqtl/ \\\n--metaxcan_filter \"CARDIoGRAM_C4D_CAD_ADDITIVE__PM__(.*).csv\" \\\n--metaxcan_file_name_parse_pattern \"(.*)__PM__(.*).csv\" \\\n--gwas_file $DATA/spredixcan/imputed_CARDIoGRAM_C4D_CAD_ADDITIVE.txt.gz \\\n--snp_column panel_variant_id --effect_allele_column effect_allele --non_effect_allele_column non_effect_allele --zscore_column zscore --keep_non_rsid --model_db_snp_key varID \\\n--cutoff_condition_number 30 \\\n--verbosity 9 \\\n--throw \\\n--output $RESULTS/smultixcan/eqtl/CARDIoGRAM_C4D_CAD_ADDITIVE_smultixcan.txt\n\n```\n:::\n\n\n# Colocalization Methods (Review)\n\nColocalization methods seek to estimate the probability that the complex trait and expression causal variants are the same. We favor methods that calculate the probability of causality for each trait (posterior inclusion probability), called fine-mapping methods. Here we use susie for fine-mapping and coloc for colocalization.\n\n![](https://raw.githubusercontent.com/hakyimlab/QGT-Columbia-HKI/master/extras/figures/colocalization-run.png)\n\n## Questionnaire 5\n\n-   [ ] Open and start filling questionnaire 05 Colocalization https://forms.gle/NfH2MSdy4UyJzGAp7\n\n## Run colocalization\n\nWhen you use coloc on your own data, you may want to check out coloc's documentation, with good advice and tips on avoiding common mistakes https://cran.r-project.org/web/packages/coloc/vignettes\n\nDue to time constraints, we will run one region and one gene only\n\n1.  Finemap GWAS of CAD\n2.  Finemap eQTL of SORT1\n\nFor finemapping, we need the summary statistics (effect size, standard errors, etc) and the correlation between SNPs (LD matrix)\n\n## load the genotype to calculate the ld matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load the genotype to calculate the ld matrix\nX_mat <- BEDMatrix(glue::glue(\"{DATA}/colocalization/geuvadis_chr1\"))\ncolnames(X_mat) <- gsub(\"\\\\_.*\", \"\",colnames(X_mat))\ncolnames(X_mat) <- str_replace_all(colnames(X_mat),\":\",\"_\")\nsnp_info <- fread(glue::glue(\"{DATA}/colocalization/geuvadis_chr1.bim\")) %>% \n  setnames(., colnames(.), c(\"chr\", \"snp\", \"cm\", \"pos\", \"alt\", \"ref\")) \n\nsnp_info$snp <- str_replace_all(snp_info$snp,\":\",\"_\")\n```\n:::\n\n\n## Load the eqtl and gwas effect size files\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load the eqtl effect sizes\ngene_ss <- fread(glue::glue(\"{DATA}/colocalization/Liver_chr1.txt\"))\n\n# load gwas effect sizes\ngwas <- data.table::fread(glue::glue(\"{DATA}/spredixcan/imputed_CARDIoGRAM_C4D_CAD_ADDITIVE.txt.gz\"))\n\n# filter to select genome wide significant snps at 5 × 10−8\nfiltered_regions <- gwas %>% dplyr::filter(pvalue < 5e-8)\n\n# load the ld block\nldblocks <-read_tsv(glue::glue(\"{DATA}/spredixcan/eur_ld.hg38.txt.gz\"))\n```\n:::\n\n\n## Find regions with the strongest signal in the gwas\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the loci where the significant snps are located\nfor (n in 1:nrow(filtered_regions)){\n  # extract genename, start and end\n  variant_id <- as.character(filtered_regions[n,\"variant_id\"])\n  variant_chr <- as.character(filtered_regions[n,\"chromosome\"])\n  variant_pos <- as.numeric(filtered_regions[n,\"position\"])\n  #gene_end <- as.numeric(genes[n,\"end\"])\n\n  locus <- ldblocks %>%\n    dplyr::filter(chr == variant_chr) %>%\n    filter(variant_pos >= start & variant_pos < stop) %>%\n    mutate(locus_name = paste0(chr,\"_\",start,\"_\",stop)) %>%\n    dplyr::rename(locus_start=start,locus_end=stop) %>%\n    mutate(variant_id = variant_id, position=variant_pos)\n\n  # create a data frame with info\n  if (exists('all_loci') && is.data.frame(get('all_loci'))) {\n    all_loci <- rbind(all_loci,locus)\n  } else {\n    all_loci <- locus\n  }\n}\n\n# select uniq loci\nd_loci <- all_loci %>%\n  dplyr::select(locus_name,chr,locus_start,locus_end) %>%\n  dplyr::distinct()\n```\n:::\n\n\n## select a region to run coloc\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select regions to fine map. we are going to use regions in chromosome 1\nuniq_loci <- d_loci %>% dplyr::filter(\"chr1\" == chr)\nn = 3 # chr1_107867043_109761309 region\n\n# extract information\nl_chr = as.numeric(str_remove(uniq_loci[n,\"chr\"],\"chr\"))\ns_chr = uniq_loci[n,]$chr\nl_start = uniq_loci[n,]$locus_start\nl_stop = uniq_loci[n,]$locus_end\nl_name = uniq_loci[n,]$locus_name\n```\n:::\n\n\n## Prepare gwas data for coloc\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select snps for the region from the summary stats\nss <- gwas %>% \n  dplyr::filter(chromosome == s_chr) %>%\n  dplyr::filter(position >= l_start & position <= l_stop) %>% \n  dplyr::filter(! is.na(effect_size))\n\n# find the snps in the genotype to calculate the correlation\ng.snps <- ss %>% inner_join(snp_info %>% mutate(chr = glue::glue(\"chr{chr}\")), \n                            by=c(\"chromosome\" = \"chr\",\"panel_variant_id\" = \"snp\"))\n\n\n# select genotype to calculate correlation\n#f_mat <- X_mat[,g.snps$snp]\nf_mat <- X_mat[,g.snps$panel_variant_id]\n\n# calculate corr\nR = cora(f_mat) # the package is for speed\n\n## clean up\nrm(f_mat)\n\nff <- g.snps %>% dplyr::filter(! is.na(effect_size)) %>% #select(-snp) %>% \n  dplyr::rename(snp=panel_variant_id,beta=effect_size) %>% \n  mutate(varbeta = standard_error^2) %>% \n  dplyr::select(beta,varbeta,snp,position) %>% as.list()\n\nff$type <- \"cc\"\nff$sdY <- 1\n\nff$LD = R\nff$N = 184305\n\n## check the data (NULL means it's fine)\ncheck_dataset(ff)\n```\n:::\n\n\n## Prepare eqtl data for coloc\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Using SORT1 gene and liver tissue\ngene <- gene_ss %>% dplyr::filter(gene_id == \"ENSG00000134243.11\") %>% \n  dplyr::rename(snp = variant_id,beta = slope, MAF = maf,\n                pvalue = pval_nominal) %>% \n  mutate(varbeta = slope_se^2, name = snp) %>% \n  filter(! is.na(varbeta)) %>% \n  separate(name, into = c(\"chr\", \"position\",\"ref\",\"alt\",\"build\"),sep = \"_\")\n\n## calculate the ld matrix\n### get the snps\ngene.snps <- gene %>% mutate(position = as.integer(position)) %>% \n  inner_join(snp_info %>% mutate(chr = glue::glue(\"chr{chr}\")), \n                              by=c(\"chr\" = \"chr\",\"snp\" = \"snp\"))\n\n# select genotype to calculate correlation\ng_mat <- X_mat[,gene.snps$snp]\n# calculate corr\ng.R = cora(g_mat)\n\n# clean up\nrm(g_mat)\n\n# format data for coloc\ngg <- gene %>% dplyr::filter(snp %in% gene.snps$snp) %>%\n  mutate(position = as.integer(position)) %>% \n  dplyr::select(beta,varbeta,snp,position,MAF, pvalue) %>% as.list()\n\ngg$type <- \"quant\"\ngg$LD = g.R\ngg$N = 208 # 670 for blood\n\n## check the data\ncheck_dataset(gg)\n```\n:::\n\n\n## run older version of coloc which assumes single causal variant\n\n*coloc.abf* makes the simplifying assumption that each trait has at most one causal variant in the region under consideration\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.res <- coloc.abf(dataset1=ff, dataset2=gg)\nsensitivity(my.res,\"H4 > 0.9\")\n```\n:::\n\n\n## run coloc allowing multiple causal variants\n\nMultiple causal variants, using SuSiE to separate the signals\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Run susie fine maooing\nS3 = runsusie(ff)\nS4 = runsusie(gg)\n#summary(S3)\n\n# Run coloc\nsusie.res=coloc.susie(S3,S4)\nprint(susie.res$summary)\n```\n:::\n\n\nSuSiE can take a while to run on larger datasets, so it is best to run once per dataset with the =runsusie= function, store the results and feed those into subsequent analyses.\n\nplot the coloc result with the sensitivity function because weird effects are much easier to understand visually\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsensitivity(susie.res,\"H4 > 0.9\",row=1,dataset1=ff,dataset2=gg,)\n```\n:::\n\n\n# cTWAS\n\ncTWAS stands for causal TWAS and seeks to calculate the posterior inclusion probability of genes and SNPs in a given region to be causal. It's a modification of SUSIER that adds predicted gene expression levels in addition to SNPs in the analysis. It is not yet published, but the authors (Siming Zhao, Wesley Crouse, Matthew Stephens et al) have shared a vignette with us to try it out.\n\n> Thank you, Wes, for creating this portion of the lab!\n\n## Questionnaire 06\n\n-   [ ] Open and start filling out questionnaire 06 cTWAS https://forms.gle/A4evWkbhR7cXLy36A\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages(\"R.utils\")\n\n#install.packages(\"remotes\")\n#remotes::install_github(\"simingz/ctwas\", ref = \"develop\")\n\nlibrary(ctwas)\n\n#get positions for region of interest (SORT1/PSRC1 locus)\nregion <- unlist(strsplit(spredixcan_association$region_id[spredixcan_association$gene_name==\"PSRC1\"], \"_\"))\nchr <- region[2]\nstart <- as.numeric(region[3])\nend <- as.numeric(region[4])\n\n#format summary statistics (and subset to variants in region to save memory)\nz_snp <- data.table::fread(glue::glue(\"{DATA}/spredixcan/imputed_CARDIoGRAM_C4D_CAD_ADDITIVE.txt.gz\"), select=c(\"chromosome\", \"position\", \"variant_id\", \"effect_allele\", \"non_effect_allele\", \"zscore\", \"sample_size\"))\nz_snp <- z_snp[z_snp$chromosome==chr & z_snp$position >= start & z_snp$position <= end,]\nz_snp <- z_snp[!is.na(z_snp$variant_id),-(1:2)]\ncolnames(z_snp) <- c(\"id\", \"A1\", \"A2\", \"z\", \"ss\")\n\n#specify directories for LD matrices and weights\nld_R_dir <- glue::glue(\"{DATA}/cTWAS/LD_matrices\")\nweight <-  glue::glue(\"{MODEL}/gtex_v8_mashr/mashr_Liver.db\")\n\n#specify output locations and names for cTWAS\noutputdir <- glue::glue(\"{DATA}/cTWAS/results/\")\noutname.e <- \"CARDIoGRAM_Liver_expr\"\noutname <- \"CARDIoGRAM_Liver_ctwas\"\n\n#impute gene z scores using cTWAS and save the results\n##################################\n# NOTE: we are skipping this step and using the precomputed values \n## takes ~10 minutes\n##################################\n# ctwas_imputation <- impute_expr_z(z_snp=z_snp, weight=weight, ld_R_dir=ld_R_dir, outputdir=outputdir, outname=outname.e, harmonize_z=F, harmonize_wgt=F)\n# save(ctwas_imputation, file = paste0(outputdir, outname.e, \"_output.Rd\"))\nload(paste0(outputdir, outname.e, \"_output.Rd\"))\n\nz_gene <- ctwas_imputation$z_gene\nld_exprfs <- ctwas_imputation$ld_exprfs\nz_snp <- ctwas_imputation$z_snp\n\n#make custom region file for single region\nld_regions_custom <- data.frame(\"chr\" = chr, \"start\" = start, \"stop\" = end)\n\nwrite.table(ld_regions_custom, \n            file= paste0(outputdir, \"ld_regions_custom.txt\"),\n            row.names=F, col.names=T, sep=\"\\t\", quote = F)\n    \nld_regions_custom <- paste0(outputdir, \"ld_regions_custom.txt\")\n\n#run cTWAS with pre-specified prior parameters at a single locus\n#estimating prior requires genome-wide data, too slow for demonstration\n#prior is 1% inclusion for genes and is 100x more likely than SNPs\n#prior assumes genes have larger effect size than SNPs, in reasonable range for data we've looked at\nctwas_rss(z_gene=z_gene, z_snp=z_snp, ld_exprfs=ld_exprfs, ld_R_dir = ld_R_dir, ld_regions_custom=ld_regions_custom, outputdir = outputdir, outname = outname, thin = 0.01,\n          estimate_group_prior = F,\n          estimate_group_prior_var = F,\n          group_prior=c(0.01, 0.0001),\n          group_prior_var=c(50, 25))\n\n#load results\nctwas_results <- data.table::fread(paste0(outputdir,outname,\".susieIrss.txt\"))\n\n#merge gene names into the results\nsqlite <- RSQLite::dbDriver(\"SQLite\")\ndb = RSQLite::dbConnect(sqlite, weight)\nquery <- function(...) RSQLite::dbGetQuery(db, ...)\nextra_table <- query(\"select * from extra\")\nRSQLite::dbDisconnect(db)\n\nctwas_results$genename <- extra_table$genename[match(ctwas_results$id, extra_table$gene)]\n\n#show results with highest PIPs\ncol_order_2= c(\"genename\", \"chrom\", \"id\", \"pos\", \"type\", \"region_tag1\", \"region_tag2\", \"cs_index\", \"susie_pip\" , \"mu2\")\nctwas_results <- ctwas_results[, ..col_order_2]\nhead(ctwas_results[order(-ctwas_results$susie_pip),])\n```\n:::\n\n\n# FAQ and frequent errors\n\n-   conda environment may not load correctly after resuming the project in Rstudio cloud\n\n-   when inner joining by ensemble id of genes, make sure that both datasets have either the same versions or remove versions\n\n# Contributors\n\n-   Festus Nyasimi\n-   Margaret Perry\n-   Wes Crouse\n-   Owen Melia\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}