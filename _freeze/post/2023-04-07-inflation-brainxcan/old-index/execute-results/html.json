{
  "hash": "0075e325624d392adc49a135e54493b6",
  "result": {
    "markdown": "---\ntitle: \"Old Inflation Brainxcan\"\nauthor: \"Haky Im\"\ndate: \"2023-04-07\"\ncategories: [analysis]\neditor_options: \n  chunk_output_type: console\nformat:\n  html:\n    code-fold: false\n    code-summary: \"Show the code\"\n    code-tools: true\n    code-overflow: wrap\n---\n\n\n## define parameters for simulation multiple comb of nsam and msnp\n\n::: {.cell}\n\n```{.r .cell-code}\nnsam = 10000\nnsim = 150\nmidp = 100\nmsnp = 1000\n\nh2Y = 0.5\n##h2IDP = 0.1 + runif(midp) * 0.8\nh2IDP = 0.1 + 0.8 * (1:midp)/midp\n\nnsamlist = c(100,1000,5000,10000); num_nsam=length(nsamlist)\nmsnplist = c(99,999,4999); num_msnp=length(msnplist)\n```\n:::\n\n\n\n## perform simulation\nthis should be ran in parallel\n\n::: {.cell}\n\n```{.r .cell-code}\nrerun=FALSE\n\nif(rerun)\n{\n  varchi2mat = array(NA, dim=c(num_nsam, num_msnp, midp) )\n  trrtrmat = matrix(NA,num_nsam, num_msnp)\n  for(ii in 1:num_nsam)\n  {\n    for(jj in 1:num_msnp)\n    {\n      res=list()\n      print(ii)\n      print(jj)\n      print(nsamlist[ii])\n      print(msnplist[jj])\n      res = simulate_study(nsam=nsamlist[ii],msnp=msnplist[jj],nsim,midp,h2IDP,h2Y)\n      varchi2mat[ii,jj,] = res$varchi2\n      trrtrmat[ii,jj] = res$trrtr\n    }\n  }\n  rownames(trrtrmat) = paste0(\"n\",nsamlist)\n  colnames(trrtrmat) = paste0(\"m\",msnplist)\n  dimnames(varchi2mat) = list(rownames(trrtrmat), colnames(trrtrmat), paste0(\"h2.\",h2IDP))\n  saveRDS(varchi2mat,glue(\"{DATA}/varchi2mat-h2Y{h2Y}.RDS\"))\n  saveRDS(trrtrmat,glue(\"{DATA}/trrtrmat-h2Y{h2Y}.RDS\"))\n} else\n{\n  varchi2mat = readRDS(glue(\"{DATA}/varchi2mat-h2Y{h2Y}.RDS\"))\n  trrtrmat = readRDS(glue(\"{DATA}/trrtrmat-h2Y{h2Y}.RDS\"))\n}\n```\n:::\n\n\n## plotting varZ - 1 divided by nsam and tr(RR')/tr(R)^2\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the margin size\nmar_size <- 0.5\n\n# Adjust the plot margins\npar(mfrow = c(num_nsam, num_msnp), mar = c(mar_size, mar_size, mar_size, mar_size) + 0.1)\n\n# Create the plots\nfor (ii in 1:num_nsam) {\n  for (jj in 1:num_msnp) {\n    nsam <- nsamlist[ii]\n    msnp <- msnplist[jj]\n    plot(h2IDP, (varchi2mat[ii, jj, ] - 1) / trrtrmat[ii, jj] / nsamlist[ii], \n         xlab = \"h2IDP\", \n         ylab = \"(varz-1) / N / trrtr\", \n         xlim = c(0, 1), \n         ylim = c(0, 1))\n    # Add nsam and msnp information as text\n    text(x = 0.5, y = 0.9, labels = paste(\"nsam =\", nsam, \", msnp =\", msnp), adj = c(0.5, 0.5))\n    abline(0, 1)\n    abline(0, h2Y, col = 'blue')\n    grid()\n  }\n}\n\n# Reset plotting parameters to defaults\npar(mfrow = c(1, 1))\n\n# Add title to the entire plot\ntitle(\"(varZ - 1 ) /nsam/tRRt2R vs h2IDP - blue line has slope h2Y\", outer = TRUE, line = -1)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressMessages(library(tidyverse))\nsuppressMessages(library(glue))\n\nPRE = \"/Users/haekyungim/Library/CloudStorage/Box-Box/LargeFiles/imlab-data/data-Github/web-data\"\nSLUG=\"inflation-brainxcan\" ## copy the slug from the header\nbDATE='2023-04-07' ## copy the date from the blog's header here\nDATA = glue(\"{PRE}/{bDATE}-{SLUG}\")\nif(!file.exists(DATA)) system(glue::glue(\"mkdir {DATA}\"))\nWORK=DATA\n##system(glue(\"open {DATA}\")) ## this will open the folder \n```\n:::\n\n\n## Load and Define Functions\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressMessages(devtools::source_gist(\"115403f16bec0a0e871f3616d552ce9b\") ) ## load fn_ratxcan, fast regression and other convenience functions to correlate subsets of columns of two matrices\nsuppressMessages(devtools::source_gist(\"38431b74c6c0bf90c12f\") ) ## load qqunif\n\n\nmy_trace = function(mat) if(nrow(mat)==ncol(mat)) sum(diag(mat)) else error(\"matrix is not diagonal\")\nqqR2 <- function(corvec,nn,pad_neg_with_0 = FALSE,...)\n{\n## nn is the sample size, number of individuals used to compute correlation.\n## needs correlation vector as input.\n## nullcorvec generates a random sample from correlation distributions, under the null hypothesis of 0 correlation using Fisher's approximation.\n  if(pad_neg_with_0) corvec[corvec < 0 | is.na(corvec) ]=0\n  mm <- length(corvec)\n  nullcorvec = tanh(rnorm(mm)/sqrt(nn-3)) ## null correlation vector\n  qqplot(nullcorvec^2,corvec^2,...); abline(0,1); grid()\n}\n\nqqR <- function(corvec,nn,...)\n{\n## nn is the sample size, number of individuals used to compute correlation.\n## needs correlation vector as input.\n## nullcorvec generates a random sample from correlation distributions, under the null hypothesis of 0 correlation using Fisher's approximation.\n  mm <- length(corvec)\n  nullcorvec = tanh(rnorm(mm)/sqrt(nn-3)) ## null correlation vector\n  qqplot(nullcorvec,corvec,...); abline(0,1); grid()\n}\n\n## calculate p-value from correlation\ncor2zscore = function(cc,nn) \n{\n  zz = atanh(cc) * sqrt(nn-3)\n}\n\ncor2pval = function(cc,nn) \n{\n  zz=cor2zscore(cc,nn)\n  pnorm(-abs(zz))*2\n}\n\ncor2chi2 = function(cc,nn)\n{\n  cor2zscore(cc,nn)^2\n}\n```\n:::\n\n\n\n\n\n# Analysis for one parameter set. See above for runs organized across multiple sample size and number of snps\n\n\n\n## Define Parameters\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnsam = 10000\nnsim = 150\nmidp = 100\nmsnp = 1000\n\nh2Y = 0.5\nh2IDP = 0.1 + runif(midp) * 0.8\n```\n:::\n\n\n## Simulate X Matrix\n\nThis section simulates the X matrix, which is a matrix of binomial random numbers. The X matrix is then scaled, and a trace function is defined and used to calculate the trace of R.\n\n::: {.cell}\n\n```{.r .cell-code}\nXmat = matrix(rbinom(nsam*msnp, 2, 0.4), nsam, msnp)\n\nR = scale(Xmat)\nif(nsam >  msnp) \n{\n  R = t(R)\n  MM = nsam\n} else MM = msnp\n    \nR = ( R %*% t(R) ) / MM\n\ntrrtr = my_trace( t(R) %*% R ) / my_trace(R)^2\n```\n:::\n\n\n## Simulate Polygenic Y (nsam x nsim)\n\nThis section simulates polygenic Y values based on the equation given.\n\n```{=tex}\n\\begin{align}\nY &= \\beta \\cdot \\text{IDP} + \\sum_k X_k \\cdot b_k + \\epsilon\n\\end{align}\n```\n\n::: {.cell}\n\n```{.r .cell-code}\nbetamat = matrix(rnorm(msnp*nsim),msnp, nsim)\nepsimat = matrix(rnorm(nsam*nsim),nsam, nsim)\nepsimat = scale(epsimat) * sqrt(1 - h2Y)\ngYmat = Xmat %*% betamat\ngYmat = scale(gYmat) * sqrt(h2Y)\nYmat = gYmat + epsimat\n```\n:::\n\n\n- Simulate Polygenic IDP (nsam x midp)\n\nThis section simulates polygenic IDP values based on the equation given.\n\n```{=tex}\n\\begin{align}\n\\text{IDP} &= \\sum_k \\gamma_k \\cdot X_k + \\epsilon',\n\\end{align}\n```\n\n::: {.cell}\n\n```{.r .cell-code}\ngammamat = matrix(rnorm(msnp * midp),msnp, midp)\nepsimat2 = matrix(rnorm(nsam * midp),nsam, midp)\nepsimat2 = scale(epsimat2)\nepsimat2 = sweep(epsimat2, MARGIN=2, sqrt(1 - h2IDP), FUN=\"*\" )\n\ngIDPmat = Xmat %*% gammamat\ngIDPmat = scale(gIDPmat) \ngIDPmat = sweep(gIDPmat, MARGIN=2, sqrt(h2IDP), FUN=\"*\" )\nIDPmat = gIDPmat + epsimat2\n```\n:::\n\n\n\n## Calculate P-value of Regression, Y ~ IDP\n\nIn this section, we calculate the p-value of the regression, Y ~ IDP. First, we load required functions, then scale the Y and IDP matrices. We compute the correlation matrix and calculate p-values from the correlation. Lastly, we visualize the results and print the summary of the linear regression.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## scale Ymat\nYmat = scale(Ymat)\n\n## scale IDPmat\nIDPmat = scale(IDPmat)\n\n## multiply t(Ymat) %*% IDPmat\ncormat = t(Ymat) %*% IDPmat\ncormat = cormat / nsam\n\n\n\npmat = cor2pval(cormat,nn=nsam)\n\nchi2mat = cor2chi2(cormat,nn=nsam)\nvarchi2 = apply(chi2mat,2,mean)\n\nrangoy = range(c(0,varchi2-1))\nplot(h2IDP,varchi2-1,ylim=rangoy, xlim=c(0,1)); grid()\n\nprint(\"intercept should be close to 1 and slope proportional to nsam\")\nsummary(lm(varchi2 ~ h2IDP))\n```\n:::\n\n\n- [ ] run regression with multiple combination of sample sizes and number of SNPs\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnsam = 10000\nmsnp = 1000\nnsim = 150\nmidp = 100\nh2Y = 0.5\nh2IDP = 0.1 + runif(midp) * 0.8\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-   [ ] calculate pvec of cor(Y, IDP): this is the same as running linear regression\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# > summary(lm(Ymat~ IDPmat[,32]))\n# \n# Call:\n# lm(formula = Ymat ~ IDPmat[, 32])\n# \n# Residuals:\n#      Min       1Q   Median       3Q      Max \n# -201.069  -46.406   -0.164   46.472  205.379 \n# \n# Coefficients:\n#               Estimate Std. Error t value Pr(>|t|)    \n# (Intercept)  -37.14480    4.61728  -8.045 2.44e-15 ***\n# IDPmat[, 32]  -0.08780    0.03051  -2.878  0.00409 ** \n# ---\n# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n# \n# Residual standard error: 68.63 on 998 degrees of freedom\n# Multiple R-squared:  0.008231,\tAdjusted R-squared:  0.007237 \n# F-statistic: 8.282 on 1 and 998 DF,  p-value: 0.004088\n# \n# > cor.test(Ymat, IDPmat[,32])\n# \n# \tPearson's product-moment correlation\n# \n# data:  Ymat and IDPmat[, 32]\n# t = -2.8779, df = 998, p-value = 0.004088\n# alternative hypothesis: true correlation is not equal to 0\n# 95 percent confidence interval:\n#  -0.15186241 -0.02889285\n# sample estimates:\n#         cor \n# -0.09072344 \n```\n:::\n\n\n<!-- -   [ ] calculate pvec of cor(sum bk Xk, sum gammak Xk) -->\n\n<!-- ```{r fit gY on gIDP} -->\n<!-- ## run fast_predixcan_assoc -->\n<!-- idnum=1:nsam -->\n<!-- idvec = glue(\"id-{idnum}\") -->\n<!-- gres <- fast_predixcan_assoc(data.frame(IID=idvec,gIDPmat), data.frame(IID=idvec,gYmat), idlist=idvec) -->\n<!-- qqunif(gres$pval) -->\n\n<!-- ``` -->\n\n\n-   [ ] check FDR of BrainXcan schizophrenia associations\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## google sheets prepared by Yanyu for revision 4/7/2023\ns2 <- read_csv(glue(\"{DATA}/Table_S2.xlsx - ..csv\"))\ns8 <- read_csv(glue(\"{DATA}/Table_S8-w-factor.xlsx - Table_S8-w-factor.csv\"))\n\ntempo <- s8 %>% left_join(s2 %>% select(IDP,modality,notes,subtype),by=c(\"IDP\")) %>% filter(model==\"ridge\",phenotype==\"SCZ_PGC_2020\") %>% filter(substr(subtype, 1, 2) != 'w-' | is.na(subtype) ) %>% filter(!grepl(\"ProbTrack-1\",IDP))\n\n## qq <- tempo %>% filter(modality==\"dMRI\") %>% .[[\"pval_adj_perm_null\"]] %>% qvalue::qvalue()\n\nqq <- tempo  %>% .[[\"pval_adj_perm_null\"]] %>% qvalue::qvalue()\n```\n:::\n\n\n-   [ ] read hapmap file\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# if (!require(\"BiocManager\", quietly = TRUE))\n#     install.packages(\"BiocManager\")\n# BiocManager::install(\"snpStats\")\nsuppressMessages(library(snpStats))\n# Set the path to the binary files (without file extensions)\nplink_file_path <- \"/Users/haekyungim/Library/CloudStorage/Box-Box/LargeFiles/imlab-data/Reference-Data/GWAS-tutorial-Marees/data_1_QC_GWAS/HapMap_3_r3_1\"\n# Read the binary files into an object of class \"snpMatrix\"\nsnp_matrix <- read.plink(plink_file_path)\n```\n:::\n",
    "supporting": [
      "old-index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}