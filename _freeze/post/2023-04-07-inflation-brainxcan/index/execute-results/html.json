{
  "hash": "09f2f739ccbf52a8f7d4652a59e48561",
  "result": {
    "markdown": "---\ntitle: \"Inflation Brainxcan\"\nauthor: \"Haky Im\"\ndate: \"2023-04-07\"\ncategories: [analysis]\ndate-modified: last-modified\neditor_options: \n  chunk_output_type: console\nformat:\n  html:\n    code-fold: false\n    code-summary: \"Show the code\"\n    code-tools: true\n    code-overflow: wrap\n---\n\n\n::: {.callout-tip}\n## Summary\nWhen both $Y$ and a mediator IDP are polygenic, the regression test $Y$ on IDP is inflated with $\\text{Var}(Z_\\text{bxcan}) = 1 + N h_1^2 \\cdot \\frac{\\text{tr}(R'R)}{\\text{tr}^2(R)}$. I'll use simulations to understand this relationship as functions of $h_Y$, $h_\\text{IDP}$, $N$, $M_Y$, and $M_\\text{IDP}$. \n:::\n\n- $h_Y$ is the heritability of $Y$\n- $h_\\text{IDP}$\n- $N$, is the sample size = nsam\n- $M_Y$ is the number of causal variants for Y\n- $M_\\text{IDP}$ is the number of causal variants for the IDP\n\nHere $M_Y = M_\\text{IDP}$ = msnp.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressMessages(library(tidyverse))\nsuppressMessages(library(glue))\n\nPRE = \"/Users/haekyungim/Library/CloudStorage/Box-Box/LargeFiles/imlab-data/data-Github/web-data\"\nSLUG=\"inflation-brainxcan\" ## copy the slug from the header\nbDATE='2023-04-07' ## copy the date from the blog's header here\nDATA = glue(\"{PRE}/{bDATE}-{SLUG}\")\nif(!file.exists(DATA)) system(glue::glue(\"mkdir {DATA}\"))\nWORK=DATA\n##system(glue(\"open {DATA}\")) ## this will open the folder \n```\n:::\n\n\n## Load and Define Functions\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressMessages(devtools::source_gist(\"115403f16bec0a0e871f3616d552ce9b\") ) ## load fn_ratxcan, fast regression and other convenience functions to correlate subsets of columns of two matrices\nsuppressMessages(devtools::source_gist(\"38431b74c6c0bf90c12f\") ) ## load qqunif\n\n\nmy_trace = function(mat) if(nrow(mat)==ncol(mat)) sum(diag(mat)) else error(\"matrix is not diagonal\")\nqqR2 <- function(corvec,nn,pad_neg_with_0 = FALSE,...)\n{\n## nn is the sample size, number of individuals used to compute correlation.\n## needs correlation vector as input.\n## nullcorvec generates a random sample from correlation distributions, under the null hypothesis of 0 correlation using Fisher's approximation.\n  if(pad_neg_with_0) corvec[corvec < 0 | is.na(corvec) ]=0\n  mm <- length(corvec)\n  nullcorvec = tanh(rnorm(mm)/sqrt(nn-3)) ## null correlation vector\n  qqplot(nullcorvec^2,corvec^2,...); abline(0,1); grid()\n}\n\nqqR <- function(corvec,nn,...)\n{\n## nn is the sample size, number of individuals used to compute correlation.\n## needs correlation vector as input.\n## nullcorvec generates a random sample from correlation distributions, under the null hypothesis of 0 correlation using Fisher's approximation.\n  mm <- length(corvec)\n  nullcorvec = tanh(rnorm(mm)/sqrt(nn-3)) ## null correlation vector\n  qqplot(nullcorvec,corvec,...); abline(0,1); grid()\n}\n\n## calculate p-value from correlation\ncor2zscore = function(cc,nn) \n{\n  zz = atanh(cc) * sqrt(nn-3)\n}\n\ncor2pval = function(cc,nn) \n{\n  zz=cor2zscore(cc,nn)\n  pnorm(-abs(zz))*2\n}\n\ncor2chi2 = function(cc,nn)\n{\n  cor2zscore(cc,nn)^2\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsimulate_study = function(nsam,msnp,nsim,midp,h2IDP,h2Y)\n{\n  ## simulate Xmat (nsam x msnp)\n  Xmat = matrix(rbinom(nsam*msnp, 2, 0.4), nsam, msnp)\n\n  ## calculate GRM or LD matrix depending on min(nsam, msnp) and trrtr\n  R = scale(Xmat) ## QUESTION: DO I NEED TO SCALE ACROSS SAMPLES AND ACROSS SNPS?\n  if(nsam >  msnp) \n  {\n    R = t(R)\n    MM = nsam\n  } else MM = msnp\n  R = ( R %*% t(R) ) / MM\n  trrtr = my_trace( t(R) %*% R ) / my_trace(R)^2\n  \n  ## simulate IDPmat (nsam x mipd) \n  gammamat = matrix(rnorm(msnp * midp),msnp, midp)\n  epsimat2 = matrix(rnorm(nsam * midp),nsam, midp)\n  epsimat2 = scale(epsimat2)\n  epsimat2 = sweep(epsimat2, MARGIN=2, sqrt(1 - h2IDP), FUN=\"*\" )\n  gIDPmat = Xmat %*% gammamat\n  gIDPmat = scale(gIDPmat) \n  gIDPmat = sweep(gIDPmat, MARGIN=2, sqrt(h2IDP), FUN=\"*\" )\n  IDPmat = gIDPmat + epsimat2\n  \n  ## simulate Ymat (nsam x nsim) indep of IDPs\n  betamat = matrix(rnorm(msnp*nsim),msnp, nsim)\n  epsimat = matrix(rnorm(nsam*nsim),nsam, nsim)\n  epsimat = scale(epsimat) * sqrt(1 - h2Y)\n  gYmat = Xmat %*% betamat\n  gYmat = scale(gYmat) * sqrt(h2Y)\n  Ymat = gYmat + epsimat\n  \n  ## calc cor\n    ## scale Ymat & IDPmat\n  Ymat = scale(Ymat)\n  IDPmat = scale(IDPmat)\n    ## multiply t(Ymat) %*% IDPmat\n  cormat = t(Ymat) %*% IDPmat\n  cormat = cormat / nsam\n\n  ## calc varZ\n  chi2mat = cor2chi2(cormat,nn=nsam)\n  varZ = apply(chi2mat,2,mean)\n\n  ## build result list\n  res = list()\n  res$varZ = varZ\n  res$trrtr = trrtr\n  res\n}\n```\n:::\n\n\n## define parameters for simulation multiple comb of nsam and msnp\n\n::: {.cell}\n\n```{.r .cell-code}\nnsim = 150\nmidp = 100\nh2IDP = 0.1 + 0.8 * (1:midp)/midp\nh2Yvec = (1:9)/10\nnsamlist = c(100,1000,5000,10000); num_nsam=length(nsamlist)\nmsnplist = c(99,999,4999); num_msnp=length(msnplist)\n```\n:::\n\n\n\n## simulate and plot varZ vs h2IDP by h2Y, msnp, nsam\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrerun=TRUE\nfor(h2Y in h2Yvec)\n{\n  print(\"---------------\")\n  print(\"h2Y is\")\n  print(h2Y)\n\nif(rerun)\n{\n  varZmat = array(NA, dim=c(num_nsam, num_msnp, midp) )\n  trrtrmat = matrix(NA,num_nsam, num_msnp)\n  for(ii in 1:num_nsam)\n  {\n    for(jj in 1:num_msnp)\n    {\n      res=list()\n      #print(ii)\n      #print(jj)\n      nsam=nsamlist[ii]\n      msnp=msnplist[jj]\n      #print(nsam)\n      #print(msnp)\n      noskip = !(msnp==4999 & nsam > 4999)\n      if(noskip) \n      {\n        res = simulate_study(nsam,msnp,nsim,midp,h2IDP,h2Y)\n        varZmat[ii,jj,] = res$varZ\n        trrtrmat[ii,jj] = res$trrtr\n      }\n    }\n  }\n  rownames(trrtrmat) = paste0(\"n\",nsamlist)\n  colnames(trrtrmat) = paste0(\"m\",msnplist)\n  dimnames(varZmat) = list(rownames(trrtrmat), colnames(trrtrmat), paste0(\"h2.\",h2IDP))\n  saveRDS(varZmat,glue(\"{DATA}/varZmat-h2Y{h2Y}.RDS\"))\n  saveRDS(trrtrmat,glue(\"{DATA}/trrtrmat-h2Y{h2Y}.RDS\"))\n} else\n{\n  varZmat = readRDS(glue(\"{DATA}/varZmat-h2Y{h2Y}.RDS\"))\n  trrtrmat = readRDS(glue(\"{DATA}/trrtrmat-h2Y{h2Y}.RDS\"))\n}\n\n\n# Set the margin size\nmar_size <- 0.5\n\n# Adjust the plot margins\npar(mfrow = c(num_nsam, num_msnp), mar = c(mar_size, mar_size, mar_size, mar_size) + 0.1)\n\n# Create the plots\nfor (ii in 1:num_nsam) {\n  for (jj in 1:num_msnp) {\n    nsam <- nsamlist[ii]\n    msnp <- msnplist[jj]\n    plot(h2IDP, (varZmat[ii, jj, ] - 1) / trrtrmat[ii, jj] / nsamlist[ii], \n         xlab = \"h2IDP\", \n         ylab = \"(varz-1) / N / trrtr\", \n         xlim = c(0, 1), \n         ylim = c(0, 1))\n    # Add nsam and msnp information as text\n    noskip = !(msnp==4999 & nsam > 4999)\n    if(noskip) \n      text(x = 0.5, y = 0.9, labels = paste(\"nsam =\", nsam, \", msnp =\", msnp), adj = c(0.5, 0.5)) else text(x = 0.5, y = 0.9, labels = \"skipped simulation for speed\") \n    abline(0, 1)\n    abline(0, h2Y, col = 'blue')\n    grid()\n  }\n}\n\n# Reset plotting parameters to defaults\npar(mfrow = c(1, 1))\n\n# Add title to the entire plot\ntitle(glue(\"(varZ - 1 ) /nsam/tRRt2R vs h2IDP - blue line has slope h2Y {h2Y}\"), outer = TRUE, line = -1)\n\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"---------------\"\n[1] \"h2Y is\"\n[1] 0.1\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/sim and plot with h2yvec-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"---------------\"\n[1] \"h2Y is\"\n[1] 0.2\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/sim and plot with h2yvec-2.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"---------------\"\n[1] \"h2Y is\"\n[1] 0.3\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/sim and plot with h2yvec-3.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"---------------\"\n[1] \"h2Y is\"\n[1] 0.4\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/sim and plot with h2yvec-4.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"---------------\"\n[1] \"h2Y is\"\n[1] 0.5\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/sim and plot with h2yvec-5.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"---------------\"\n[1] \"h2Y is\"\n[1] 0.6\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/sim and plot with h2yvec-6.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"---------------\"\n[1] \"h2Y is\"\n[1] 0.7\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/sim and plot with h2yvec-7.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"---------------\"\n[1] \"h2Y is\"\n[1] 0.8\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/sim and plot with h2yvec-8.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"---------------\"\n[1] \"h2Y is\"\n[1] 0.9\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/sim and plot with h2yvec-9.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}