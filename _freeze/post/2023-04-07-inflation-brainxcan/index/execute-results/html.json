{
  "hash": "4e128bf414cb4677e09d2a12e3a0bb25",
  "result": {
    "markdown": "---\ntitle: \"Inflation Brainxcan\"\nauthor: \"Haky Im\"\ndate: \"2023-04-07\"\ncategories: [analysis]\neditor_options: \n  chunk_output_type: console\nformat:\n  html:\n    code-fold: false\n    code-summary: \"Show the code\"\n    code-tools: true\n    code-overflow: wrap\n---\n\n\n::: {.callout-tip}\n## Summary\nWhen both $Y$ and a mediator IDP are polygenic, the regression test $Y$ on IDP is inflated with $\\text{Var}(Z_\\text{bxcan}) = 1 + N h_1^2 \\cdot \\frac{\\text{tr}(R'R)}{\\text{tr}^2(R)}$. I'll use simulations to understand this relationship as functions of $h_Y$, $h_\\text{IDP}$, $N$, $M_Y$, and $M_\\text{IDP}$. \n:::\n\n- $h_Y$ is the heritability of $Y$\n- $h_\\text{IDP}$\n- $N$, is the sample size\n- $M_Y$ is the number of causal variants for Y\n- $M_\\text{IDP}$ is the number of causal variants for the IDP\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressMessages(library(tidyverse))\nsuppressMessages(library(glue))\n\nPRE = \"/Users/haekyungim/Library/CloudStorage/Box-Box/LargeFiles/imlab-data/data-Github/web-data\"\nSLUG=\"inflation-brainxcan\" ## copy the slug from the header\nbDATE='2023-04-07' ## copy the date from the blog's header here\nDATA = glue(\"{PRE}/{bDATE}-{SLUG}\")\nif(!file.exists(DATA)) system(glue::glue(\"mkdir {DATA}\"))\nWORK=DATA\n##system(glue(\"open {DATA}\")) ## this will open the folder \n```\n:::\n\n\n## Define Parameters\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnsam = 10000\nnsim = 150\nmidp = 100\nmsnp = 1000\n\nh2Y = 0.5\nh2IDP = 0.1 + runif(midp) * 0.8\n```\n:::\n\n\n## Simulate X Matrix\n\nThis section simulates the X matrix, which is a matrix of binomial random numbers. The X matrix is then scaled, and a trace function is defined and used to calculate the trace of R.\n\n::: {.cell}\n\n```{.r .cell-code}\nXmat = matrix(rbinom(nsam*msnp, 2, 0.4), nsam, msnp)\n\nR = scale(Xmat)\nif(nsam >  msnp) \n{\n  R = t(R)\n  MM = nsam\n} else MM = msnp\n    \nR = ( R %*% t(R) ) / MM\n\nmy_trace = function(mat) if(nrow(mat)==ncol(mat)) sum(diag(mat)) else error(\"matrix is not diagonal\")\ntrrtr = my_trace( t(R) %*% R ) / my_trace(R)^2\n```\n:::\n\n\n## Simulate Polygenic Y (nsam x nsim)\n\nThis section simulates polygenic Y values based on the equation given.\n\n```{=tex}\n\\begin{align}\nY &= \\beta \\cdot \\text{IDP} + \\sum_k X_k \\cdot b_k + \\epsilon\n\\end{align}\n```\n\n::: {.cell}\n\n```{.r .cell-code}\n## betamat msnp x 1 \nbetamat = matrix(rnorm(msnp*nsim),msnp, nsim)\nepsimat = matrix(rnorm(nsam*nsim),nsam, nsim)\nepsimat = scale(epsimat) * sqrt(1 - h2Y)\ngYmat = Xmat %*% betamat\ngYmat = scale(gYmat) * sqrt(h2Y)\nYmat = gYmat + epsimat\n```\n:::\n\n\n- Simulate Polygenic IDP (nsam x midp)\n\nThis section simulates polygenic IDP values based on the equation given.\n\n```{=tex}\n\\begin{align}\n\\text{IDP} &= \\sum_k \\gamma_k \\cdot X_k + \\epsilon',\n\\end{align}\n```\n\n::: {.cell}\n\n```{.r .cell-code}\ngammamat = matrix(rnorm(msnp * midp),msnp, midp)\nepsimat2 = matrix(rnorm(nsam * midp),nsam, midp)\nepsimat2 = scale(epsimat2)\nepsimat2 = sweep(epsimat2, MARGIN=2, sqrt(1 - h2IDP), FUN=\"*\" )\n\ngIDPmat = Xmat %*% gammamat\ngIDPmat = scale(gIDPmat) \ngIDPmat = sweep(gIDPmat, MARGIN=2, sqrt(h2IDP), FUN=\"*\" )\nIDPmat = gIDPmat + epsimat2\n```\n:::\n\n\n\n\n## Calculate P-value of Regression, Y ~ IDP\n\nIn this section, we calculate the p-value of the regression, Y ~ IDP. First, we load required functions, then scale the Y and IDP matrices. We compute the correlation matrix and calculate p-values from the correlation. Lastly, we visualize the results and print the summary of the linear regression.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressMessages(devtools::source_gist(\"115403f16bec0a0e871f3616d552ce9b\") ) ## load fn_ratxcan, fast regression and other convenience functions to correlate subsets of columns of two matrices\nsuppressMessages(devtools::source_gist(\"38431b74c6c0bf90c12f\") ) ## load qqunif\n\n## scale Ymat\nYmat = scale(Ymat)\n\n## scale IDPmat\nIDPmat = scale(IDPmat)\n\n## multiply t(Ymat) %*% IDPmat\ncormat = t(Ymat) %*% IDPmat\ncormat = cormat / nsam\n\n\nqqR2 <- function(corvec,nn,pad_neg_with_0 = FALSE,...)\n{\n## nn is the sample size, number of individuals used to compute correlation.\n## needs correlation vector as input.\n## nullcorvec generates a random sample from correlation distributions, under the null hypothesis of 0 correlation using Fisher's approximation.\n  if(pad_neg_with_0) corvec[corvec < 0 | is.na(corvec) ]=0\n  mm <- length(corvec)\n  nullcorvec = tanh(rnorm(mm)/sqrt(nn-3)) ## null correlation vector\n  qqplot(nullcorvec^2,corvec^2,...); abline(0,1); grid()\n}\n\nqqR <- function(corvec,nn,...)\n{\n## nn is the sample size, number of individuals used to compute correlation.\n## needs correlation vector as input.\n## nullcorvec generates a random sample from correlation distributions, under the null hypothesis of 0 correlation using Fisher's approximation.\n  mm <- length(corvec)\n  nullcorvec = tanh(rnorm(mm)/sqrt(nn-3)) ## null correlation vector\n  qqplot(nullcorvec,corvec,...); abline(0,1); grid()\n}\n\n\n## %%HERE continue here: TODO: calculate p values from correlation\n## pmat = \n## calculate p-value from correlation\ncor2zscore = function(cc,nn) \n{\n  zz = atanh(cc) * sqrt(nn-3)\n}\n\ncor2pval = function(cc,nn) \n{\n  zz=cor2zscore(cc,nn)\n  pnorm(-abs(zz))*2\n}\n\ncor2chi2 = function(cc,nn)\n{\n  cor2zscore(cc,nn)^2\n}\n\npmat = cor2pval(cormat,nn=nsam)\n\n\nchi2mat = cor2chi2(cormat,nn=nsam)\nvarchi2 = apply(chi2mat,2,mean)\n\nrangoy = range(c(0,varchi2-1))\nplot(h2IDP,varchi2-1,ylim=rangoy, xlim=c(0,1)); grid()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/fit Y on IDP-1.png){width=672}\n:::\n\n```{.r .cell-code}\nprint(\"intercept should be close to 1 and slope proportional to nsam\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"intercept should be close to 1 and slope proportional to nsam\"\n```\n:::\n\n```{.r .cell-code}\nsummary(lm(varchi2 ~ h2IDP))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = varchi2 ~ h2IDP)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-1.48335 -0.26042  0.01979  0.31662  1.32758 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)   1.0157     0.1248   8.141 1.27e-12 ***\nh2IDP         5.0204     0.2175  23.087  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.49 on 98 degrees of freedom\nMultiple R-squared:  0.8447,\tAdjusted R-squared:  0.8431 \nF-statistic:   533 on 1 and 98 DF,  p-value: < 2.2e-16\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}