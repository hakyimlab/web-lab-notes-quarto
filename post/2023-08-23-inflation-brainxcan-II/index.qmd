---
title: "Polygenicity Driven Inflation in Brainxcan II"
author: "Haky Im"
date: "2023-08-23"
categories: [analysis]
date-modified: last-modified
editor_options: 
  chunk_output_type: console
format:
  html:
    code-fold: false
    code-summary: "Show the code"
    code-tools: true
    code-overflow: wrap
description: to investigate the functional form of var(Z_TWAS)(N, h_Y, M)
---


Investigate this expression
$\text{Var}(Z_\text{bxcan}) = 1 + h_Y^2 \cdot N \cdot \Phi(\cdots)$

How does $\Phi$ relate to the traces expression?
$$\Phi \longleftrightarrow \frac{\text{tr}(R'R)}{\text{tr}^2(R)}$$
The model for Y and IDPs

$$Y = T ~ \beta + X \cdot b + \epsilon_Y$$
$$T = X \cdot \gamma$$
Error in prediction will be introduced as error in $\gamma$ later




```{r}
suppressMessages(library(tidyverse))
suppressMessages(library(glue))

PRE = "/Users/haekyungim/Library/CloudStorage/Box-Box/LargeFiles/imlab-data/data-Github/web-data"
SLUG="inflation-brainxcan-II" ## copy the slug from the header
bDATE='2023-08-23' ## copy the date from the blog's header here
DATA = glue("{PRE}/{bDATE}-{SLUG}")
if(!file.exists(DATA)) system(glue::glue("mkdir {DATA}"))
WORK=DATA
##system(glue("open {DATA}")) ## this will open the folder 
```

## copied simulation code from [previous post on polygenicity driven inflation in brainxcan](/post/2023-04-07-inflation-brainxcan)

## load and define Functions

```{r}
suppressMessages(devtools::source_gist("115403f16bec0a0e871f3616d552ce9b") ) ## load fn_ratxcan, fast regression and other convenience functions to correlate subsets of columns of two matrices
suppressMessages(devtools::source_gist("38431b74c6c0bf90c12f") ) ## load qqunif


my_trace = function(mat) if(nrow(mat)==ncol(mat)) sum(diag(mat)) else error("matrix is not diagonal")
qqR2 <- function(corvec,nn,pad_neg_with_0 = FALSE,...)
{
## nn is the sample size, number of individuals used to compute correlation.
## needs correlation vector as input.
## nullcorvec generates a random sample from correlation distributions, under the null hypothesis of 0 correlation using Fisher's approximation.
  if(pad_neg_with_0) corvec[corvec < 0 | is.na(corvec) ]=0
  mm <- length(corvec)
  nullcorvec = tanh(rnorm(mm)/sqrt(nn-3)) ## null correlation vector
  qqplot(nullcorvec^2,corvec^2,...); abline(0,1); grid()
}

qqR <- function(corvec,nn,...)
{
## nn is the sample size, number of individuals used to compute correlation.
## needs correlation vector as input.
## nullcorvec generates a random sample from correlation distributions, under the null hypothesis of 0 correlation using Fisher's approximation.
  mm <- length(corvec)
  nullcorvec = tanh(rnorm(mm)/sqrt(nn-3)) ## null correlation vector
  qqplot(nullcorvec,corvec,...); abline(0,1); grid()
}

## calculate p-value from correlation
cor2zscore = function(cc,nn) 
{
  zz = atanh(cc) * sqrt(nn-3)
}

cor2pval = function(cc,nn) 
{
  zz=cor2zscore(cc,nn)
  pnorm(-abs(zz))*2
}

cor2chi2 = function(cc,nn)
{
  cor2zscore(cc,nn)^2
}
```

```{r simulate study and calc varZ}

simulate_study = function(nsam,msnp,nsim,midp,precision_gamma,h2Y,prop_causal)
{
  ## simulate Xmat (nsam x msnp)
  Xmat = matrix(rbinom(nsam*msnp, 2, 0.4), nsam, msnp)

  ## calculate GRM or LD matrix depending on min(nsam, msnp) and trrtr
  R = scale(Xmat) ## QUESTION: DO I NEED TO SCALE ACROSS SAMPLES AND ACROSS SNPS?
  if(nsam >  msnp) 
  {
    R = t(R)
    MM = nsam
  } else MM = msnp
  R = ( R %*% t(R) ) / MM
  trrtr = my_trace( t(R) %*% R ) / my_trace(R)^2
  
  ## simulate IDPmat (nsam x mipd) 
  gammamat = matrix(rnorm(msnp * midp),msnp, midp)
  is_causal = rbinom(msnp,1,prop_causal)
  gammamat = sweep(gammamat,MARGIN=1,is_causal,FUN="*")
  gIDPmat = Xmat %*% gammamat
  gIDPmat = scale(gIDPmat) 
  gIDPmat = sweep(gIDPmat, MARGIN=2, sqrt(precision_gamma), FUN="*" )
  
  egammamat = matrix(rnorm(msnp * midp),msnp, midp)
  eIDPmat = Xmat %*% egammamat
  eIDPmat = scale(eIDPmat) 
  eIDPmat = sweep(eIDPmat, MARGIN=2, sqrt(1 - precision_gamma), FUN="*" )

  IDPmat = gIDPmat + eIDPmat
  
  ## simulate Ymat (nsam x nsim) indep of IDPs
  betamat = matrix(rnorm(msnp*nsim),msnp, nsim)
  epsimat = matrix(rnorm(nsam*nsim),nsam, nsim)
  epsimat = scale(epsimat) * sqrt(1 - h2Y)
  gYmat = Xmat %*% betamat
  gYmat = scale(gYmat) * sqrt(h2Y)
  Ymat = gYmat + epsimat
  
  ## calc cor
    ## scale Ymat & IDPmat
  Ymat = scale(Ymat)
  IDPmat = scale(IDPmat)
    ## multiply t(Ymat) %*% IDPmat
  cormat = t(Ymat) %*% IDPmat
  cormat = cormat / nsam

  ## calc varZ
  chi2mat = cor2chi2(cormat,nn=nsam)
  varZ = apply(chi2mat,2,mean)

  ## build result list
  res = list()
  res$varZ = varZ
  res$trrtr = trrtr
  res
}


```

## define parameters for simulation multiple comb of nsam and msnp

```{r}
nsim = 150
midp = 99
precision_gamma = 0.1 + 0.8 * (1:midp)/midp
h2Yvec = (1:9)/10; num_h2Y = length(h2Yvec)
nsamlist = c(100,1000,5000,10000); num_nsam=length(nsamlist)
msnplist = c(99,999,4999); num_msnp=length(msnplist)
prop_causal=1
```

## simulate and plot varZ vs precision_gamma by h2Y, msnp, nsam

```{r sim}
rerun=TRUE
if(rerun)
{
  varZarray = array(NA, dim=c(num_h2Y,num_nsam, num_msnp, midp))
  trrtrarray = array(NA,dim=c(num_h2Y,num_nsam, num_msnp))
  for(hh in 1:num_h2Y)
  {
    h2Y = h2Yvec[hh]
    print("---------------")
    print("h2Y is")
    print(h2Y)
    
    # varZmat = array(NA, dim=c(num_nsam, num_msnp, midp) )
    # trrtrarray = matrix(NA,num_nsam, num_msnp)
    
    for(ii in 1:num_nsam)
    {
      for(jj in 1:num_msnp)
      {
        res=list()
        #print(ii)
        #print(jj)
        nsam=nsamlist[ii]
        msnp=msnplist[jj]
        #print(nsam)
        #print(msnp)
        noskip = !(msnp==4999 & nsam > 4999)
        if(noskip) 
        {
          res = simulate_study(nsam,msnp,nsim,midp,precision_gamma,h2Y,prop_causal)
          varZarray[hh,ii,jj,] = res$varZ
          trrtrarray[hh,ii,jj] = res$trrtr
        }
      }
    }
#    saveRDS(varZmat,glue("{DATA}/varZmat-h2Y{h2Y}-propcausal{prop_causal}.RDS"))
#    saveRDS(trrtrmat,glue("{DATA}/trrtrmat-h2Y{h2Y}-propcausal{prop_causal}.RDS"))
  }
  
    charnsamlist = paste0("n_",nsamlist)
    charmsnplist = paste0("m_",msnplist)
    charh2vec = paste0("h2Y_",h2Yvec)
    dimnames(trrtrarray) = list(charh2vec, charnsamlist,charmsnplist)
    dimnames(varZarray) = list(charh2vec, charnsamlist,charmsnplist,
                             paste0("prec_",round(precision_gamma,2)))

  saveRDS(varZarray,glue("{DATA}/varZarray-propcausal{prop_causal}.RDS"))
  saveRDS(trrtrarray,glue("{DATA}/trrtrarray-propcausal{prop_causal}.RDS"))
  
  
} else
{
  varZmat = readRDS(glue("{DATA}/varZmat-h2Y{h2Y}-propcausal{prop_causal}.RDS"))
  trrtrmat = readRDS(glue("{DATA}/trrtrmat-h2Y{h2Y}-propcausal{prop_causal}.RDS"))
}




```

```{r}
#mat = matrix(NA,num_h2Y * num_nsam * num_msnp,5)
df = data.frame(h2Y=NA,nsam=NA,msnp=NA,prec=NA,value=NA)
names(df) = c("h2Y","nsam","msnp","prec","value")
  for(hh in 1:num_h2Y)
  {
    h2Y = h2Yvec[hh]
    
    for(ii in 1:num_nsam)
    {
      nsam = nsamlist[ii]
      for(jj in 1:num_msnp)
      {
        msnp = msnplist[jj]
        for(pp in 1:length(precision_gamma))
        {  prec = round(precision_gamma[pp],2)
          df = rbind(df,c(h2Y,nsam,msnp,prec,varZarray[
          paste0("h2Y_",h2Y),
          paste0("n_",nsam),
          paste0("m_",msnp),
          paste0("prec_",prec)]))
        }
        }
    }
  }
kk=na.omit(df)
```

```{r plot}
# Set the margin size
mar_size <- 0.5

# Adjust the plot margins
par(mfrow = c(num_nsam, num_msnp), mar = c(mar_size, mar_size, mar_size, mar_size) + 0.1)

# Create the plots
for (ii in 1:num_nsam) {
  for (jj in 1:num_msnp) {
    nsam <- nsamlist[ii]
    msnp <- msnplist[jj]
    plot(h2vec, (varZarray[,ii, jj, ] - 1) /  nsamlist[ii], 
         xlab = "prec_gamma", 
         ylab = "(varz-1) / N / trrtr", 
         xlim = c(0, 1), 
         ylim = c(0, 1))
    # Add nsam and msnp information as text
    noskip = !(msnp==4999 & nsam > 4999)
    if(noskip) 
      text(x = 0.5, y = 0.9, labels = paste("nsam =", nsam, ", msnp =", msnp), adj = c(0.5, 0.5)) else text(x = 0.5, y = 0.9, labels = "skipped simulation for speed") 
    abline(0, 1)
    abline(0, h2Y, col = 'blue')
    grid()
  }
}

# Reset plotting parameters to defaults
par(mfrow = c(1, 1))

# Add title to the entire plot
title(glue("(varZ - 1 ) /nsam/tRRt2R vs precision_gamma - blue line has slope h2Y {h2Y}"), outer = TRUE, line = -1)

}
```

